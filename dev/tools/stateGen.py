f = open('..\..\src\state.h', 'w')
minPNum = 3
maxPNum = 8
f.write("#define ACCEL_TIME 75 \\\\amnt of MS that must elapse before starting to check vel safety \n \n")

f.write("/* Universal State Macros */ \n")
f.write("#define NOT_T_O(machineIn) ( (machineIn##Timeout <= 0)? 1 : (npgmTime < machineIn##Timeout) ) \n")
f.write(" \n")
f.write("#define WHILE(machineIn, condition) while( NOT_T_O(machineIn) && machineIn##VelSafetyCount < 10 && (condition) ) \n")
f.write(" \n")
'''
f.write("#define SAFETY_CHECK(machineIn) (NOT_T_O(machineIn) && machineIn##VelSafetyCount < 10) ) \ \n")
f.write("{ \ \n")
f.write("	machineIn##VelSafetyCheck(); \n")
f.write(" \n")
'''
f.write("#define LOG(machineIn) if(machineIn##Logs) writeDebugStreamLine \n")
f.write(" \n")
f.write("#define VEL_CHECK_INC(machineIn, safetyType) machineIn##VelSafetyCheck(safetyType); \\ \nmachineIn##StateCycCount++ \n")
'''
f.write("#define END_STATE(machineIn) \ \n")
f.write("machine##StateCycCount++; \ \n")
f.write("break \n")
'''
f.write(" \n")

f.write("typedef enum _tVelDir \n")
f.write("{ \n")
f.write("	velEither = -1, \n")
f.write("	velUp = 0, \n")
f.write("	velDown = 1 \n")
f.write("}tVelDir; \n")

f.write("typedef enum _tVelType \n")
f.write("{ \n")
f.write("	velSensor, \n")
f.write("	velLocalY, \n")
f.write("	velAngle \n")
f.write("} tVelType; \n")

f.write("/* /////////////// State Machine Macros (For X States) ////////////////// */ \n")
f.write("/* Create machine using: \n")
f.write("	CREATE_MACHINE (-----) \n")
f.write("	{ \n")
f.write("		--- \n")
f.write("	} \n")
f.write("*/ \n")
for cnt in range (minPNum, maxPNum+1):
	f.write("\n/*\tMacro for Machine w/ %d States\t*/" %cnt + "\n")
	f.write("#define CREATE_MACHINE_%d(machine, sensor, " %cnt)
	for st in range (0, cnt):
		f.write("state%d, " %st)
	f.write("type1, arg1Name, type2, arg2Name) \\" + "\n")

	f.write("const int machine##StateCount = %d; \\" %cnt + "\n" )

	f.write("typedef enum _tStates##machine \\" + "\n" )
	f.write("{ \\" + "\n" )
	f.write("	machine##state0, \\" + "\n" )
	f.write("	machine##state1, \\" + "\n" )
	f.write("	machine##state2, \\" + "\n" )
	f.write("	machine##state3, \\" + "\n" )
	f.write("	machine##state4 \\" + "\n" )
	f.write("}tStates##machine; \\" + "\n" )
	f.write("\\" + "\n" )

	f.write("tStates##machine machine##State = machine##state0; \\" + "\n" )
	f.write("float machine##VelSafetyThresh = -1; \\" + "\n" )
	f.write("tVelDir machine##VelSafetyDir = -1; \\" + "\n" )
	f.write("unsigned long machine##Timeout; \\" + "\n" )
	f.write("type1 machine##arg1Name; \\" + "\n" )
	f.write("type2 machine##arg2Name; \\" + "\n" )
	f.write("int machine##VelSafetyCount = 0; \\" + "\n" )
	f.write("unsigned long machine##StateStartTime = 0; \\" + "\n")
	f.write("unsigned long machine##StateCycCount = 0; \\" + "\n" )
	f.write("bool machine##Logs = 0; \\" + "\n" )

	f.write("void machine##StateChange(int stateIn, long timeout = -1, float velSafetyThresh = -1, tVelDir velDir = -1, type1 arg1In = -1, type2 arg2In = -1) \\" + "\n" )
	f.write("{ \\" + "\n" )
	f.write("	if (machine##State != stateIn) \\" + "\n" )
	f.write("	{ \\" + "\n" )
	f.write("		unsigned long curTime = npgmtime; \\" + "\n" )
	f.write("		if (timeout <= 0) \\" + "\n" )
	f.write("		{ \\" + "\n" )
	f.write("			machine##Timeout = 0; \\" + "\n" )
	f.write("		} \\" + "\n" )
	f.write("		else \\" + "\n" )
	f.write("		{ \\" + "\n" )
	f.write("			machine##Timeout = ( timeout + curTime ); \\" + "\n" )
	f.write("		} \\" + "\n" )
	f.write("		\\" + "\n" )
	f.write("		machine##VelSafetyCount = 0; \\" + "\n" )
	f.write("		machine##StateStartTime = curTime; \\" + "\n")
	f.write("		machine##StateCycCount = 0; \\" + "\n" )
	f.write("		machine##VelSafetyThresh = velSafetyThresh; \\" + "\n" )
	f.write("		machine##VelSafetyDir = velDir; \\" + "\n" )
	f.write("		machine##State = stateIn; \\" + "\n" )
	f.write("		machine##arg1Name = arg1In; \\" + "\n" )
	f.write("		machine##arg2Name = arg2In;  \\" + "\n" )
	f.write("		writeDebugStreamLine (\"%d\" #machine \"State:%d, TO:%d velS:%f, %d, %d\", npgmTime, machine##State, machine##timeout, machine##VelSafetyThresh, machine##arg1Name, machine##arg2Name); \\" + "\n" )
	f.write("	} \\" + "\n" )
	f.write("} \\" + "\n" )
	f.write("\\" + "\n" )
	f.write("void machine##VelSafetyCheck (tVelType velType = velSensor) \\" + "\n" )
	f.write("{ \\" + "\n" )
	f.write("	if (machine##VelSafetyThresh != -1 && machine##VelSafetyThresh != 0) \\" + "\n" )
	f.write("	{ \\" + "\n" )
	f.write("		if (machine##VelSafetyDir == velEither || machine##VelSafetyDir == velUp) \\" + "\n" )
	f.write("			machine##VelSafetyThresh = abs(machine##VelSafetyThresh); \\" + "\n" )
	f.write("		else if (machine##VelSafetyDir == velDown) \\" + "\n" )
	f.write("			machine##VelSafetyThresh = -1 * abs(machine##VelSafetyThresh); \\" + "\n" )
	f.write("		\\" + "\n" )
	f.write("		tHog(); \\ \n")
	f.write("		float out = 0; \\ \n")
	f.write("		bool goodVel = false; \\ \n")
	f.write("		switch (velType) \\ \n")
	f.write("		{ \\ \n")
	f.write("			case velSensor: \\ \n")
	f.write("			{ \\ \n")
	#f.write("				if (machine##StateCycCount == 0) \\ \n")
	#f.write("					velocityClear(sensor); \\ \n")
	f.write("				velocityCheck(sensor); \\ \n")
	f.write("				if (gSensor[sensor].velGood) \\ \n")
	f.write("				{ \\ \n")
	f.write("					out = gSensor[sensor].velocity; \\ \n")
	f.write("					goodVel = true; \\ \n")
	f.write("				} \\ \n")
	f.write("				break; \\ \n")
	f.write("			} \\ \n")
	f.write("			case velLocalY: \\ \n")
	f.write("			{ \\ \n")
	f.write("				out = gVelocity.x * sin(gPosition.a) + gVelocity.y * cos(gPosition.a); \\ \n")
	f.write("				goodVel = true; \\ \n")
	f.write("				break; \\ \n")
	f.write("			} \\ \n")
	f.write("			case velAngle: \\ \n")
	f.write("			{ \\ \n")
	f.write("				out = gVelocity.a; \\ \n")
	f.write("				goodVel = true; \\ \n")
	f.write("				break; \\ \n")
	f.write("			} \\ \n")
	f.write("		} \\ \n")
	f.write("		unsigned long curTime = npgmTime; \\ \n")
	f.write("		if (goodVel && curTime-machine##StateStartTime > ACCEL_TIME) \\ \n")
	f.write("		{ \\ \n")
	f.write("				if (machine##VelSafetyDir == velEither) \\" + "\n" )
	f.write("				{ \\" + "\n" )
	f.write("					if ( out < abs(machine##VelSafetyThresh) ) \\" + "\n" )
	f.write("					{ \\" + "\n" )
	f.write("						machine##VelSafetyCount ++; \\" + "\n" )
	f.write("						if(machine##Logs) writeDebugStreamLine(\"%d:\"#machine\"velSafety %f\", npgmtime, out); \\ \n")
	f.write("					} \\" + "\n" )
	f.write("				} \\" + "\n" )
	f.write("				else \\" + "\n" )
	f.write("				{ \\" + "\n" )
	f.write("					if ( (sgn(machine##VelSafetyThresh) == 1)? (out < machine##VelSafetyThresh) :  (out > machine##VelSafetyThresh) ) \\" + "\n" )
	f.write("					{ \\" + "\n" )
	f.write("						machine##VelSafetyCount ++; \\" + "\n" )
	f.write("						if(machine##Logs) writeDebugStreamLine(\"%d:\"#machine\"velSafety %f\", npgmtime, out); \\ \n")
	f.write("					} \\" + "\n" )
	f.write("				} \\" + "\n" )
	f.write("		} \\ \n")
	f.write("	} \\" + "\n" )
	f.write("} \\" + "\n" )
	f.write("\\" + "\n" )

	f.write("void machine##SafetyCheck(int timedOutState = machine##state0, type1 machine##arg1Name = -1, type2 machine##arg2Name = -1) \\" + "\n" )
	f.write("{ \\" + "\n" )
	f.write("		bool timedOut = false; \\" + "\n" )
	f.write("		bool velSafety = false; \\" + "\n" )
	f.write("		if (!NOT_T_O(machine)) \\" + "\n" )
	f.write("			timedOut = true; \\" + "\n" )
	f.write("		if (machine##VelSafetyCount >= 10) \\" + "\n" )
	f.write("			velSafety = true; \\" + "\n" )
	f.write("		\\" + "\n" )
	f.write("		if (velSafety || timedOut) \\" + "\n" )
	f.write("		{ \\" + "\n" )
	f.write("			writeDebugStreamLine(\"%d\" #machine \"safety: Timedout? %d at %d VelSafety? %d\", npgmTime, timedout, machine##Timeout, velSafety); \\" + "\n" )
	f.write("			machine##StateChange(timedOutState, machine##arg1Name, machine##arg2Name); \\" + "\n" )
	f.write("		} \\" + "\n" )
	f.write("}  " + "\n" )

f.close()
